#! /usr/bin/perl -w

# $cmuPDL: ParseRequests.pm,v 1.10 2009/07/23 01:15:58 rajas Exp $
##
# This Perl module generates indices for files containing DOT graphs.  The
# specific files created and the index mappings are listed below.
# 
#  s0_request_index.dat: 
#    Used to map <(snapshot0 filename index, local id) -> offset of request
#
#  s1_request_index.dat:
#    Used to map <(snapshot1 filename index, local id)> -> filename index and offset of request 
#
#  global_id_to_local_ids.dat: Maps <global id -> local id, and dataset, and filename index>  
#
# All files are placed in the output directory specified by the caller.
#
# NOTE!!!!!: GLOBAL IDs are always guaranteed to start at one and increment
# sequentially.  
##

package ParseRequests;

use strict;
use warnings;
use Test::Harness::Assert;
use ParseDot::DotHelper qw[parse_nodes_from_file];


# Global variables ########################


### Internal functions ####################


##
# This function is called for each edge seen.  
#
# @param self: The object container
# @param in_data_fh: The filehandle of the snapshot currently being processed.
# it's offset is set to the first edge of some request.
# @param node_name_hash: A hash of node names -> uinque ids for this req.
# @param req_edg_latency_hash: A hash of edges-><avg. latency, count> for this req.
# @param request_latency: The response-time of this request
# @param snapshot: 0 if this edge belongs to s0, 1 otherwise.
#
##
my $_handle_edges = sub {
    my $self = shift;
    
	my $in_data_fh = shift;
	my $node_name_hash = shift;
	my $req_edge_latency_hash = shift;
	my $request_latency = shift;
	my $snapshot = shift;

	while(<$in_data_fh>) {

		if(/(\d+)\.(\d+) \-> (\d+)\.(\d+) \[label=\"R: ([0-9\.]+) us\".*\]/) {

			my $src_node_id = "$1.$2";
			my $dest_node_id = "$3.$4";
            
			my $edge_latency = $5;
			
			my $src_node_name = $node_name_hash->{$src_node_id};
			my $dest_node_name = $node_name_hash->{$dest_node_id};

            ##
            # Add desired code here
            ##

        } else {
            ##
            # Add desired code here
            ##
            
			last;
		}
    }
};


##
# Removes files generated by this class from the output directory
#
# @param self: The object container
##
my $_remove_existing_files = sub {
    my $self = shift;
    
    if (-e $self->{S0_REQUEST_INDEX_FILE}) {
        print("Deleting old $self->{S0_REQUEST_INDEX_FILE}\n");
        system("rm -f $self->{S0_REQUEST_INDEX_FILE}") == 0
            or die("Could not delete old $self->{S0_REQUEST_INDEX_FILE}");
    }
    
    if(defined $self->{S1_REQUEST_INDEX_FILE}) {
        if (-e $self->{S1_REQUEST_INDEX_FILE}) {
            print("Deleting old $self->{S1_REQUEST_INDEX_FILE}\n");
            system("rm -f $self->{S1_REQUEST_INDEX_FILE}") == 0
                or die("Could not delete old $self->{S1_REQUEST_INDEX_FILE}");
        }
    }
    

	if (-e $self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE}) {
		print "Deleting old $self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE}\n";
		system("rm -f $self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE}") == 0
			or die("could not delete old $self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE}\n");
	}    
};


## 
# Iterates through requests in the snapshot specified and calls
# functions necessary to accumulate and print the indices and
# edge latencies.
#
# @param self: The object container
# @param snapshot_file: The file containing requests from s0 or s1
# @param index_file: The file to which to write the file mapping
# <request local ids> -> <offset in the snapshot file>
# @param snapshot: (0 or 1)
##
my $_handle_requests = sub {

    assert(scalar(@_) == 4);
    my ($self, $dot_files_ref, $index_file, $snapshot) = @_;
    assert($snapshot == 0 || $snapshot == 1);

    my $request_latency_files = $self->{REQUEST_LATENCY_FILES};
    # Open the index files for writing
    open(my $snapshot_idx_fh, ">$index_file")
        or die("Could not open $index_file");
    open(my $gid_to_lid_idx_fh, ">>$self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE}")
        or die("could not open $self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE}\n");
    open(my $gid_to_latency_fh, ">>$self->{GLOBAL_IDS_TO_LATENCIES_FILE}")
        or die("could not open $self->{GLOBAL_IDS_TO_LATENCIES_FILE}\n");

    my @req_latencies;

    for(my $i = 0; $i < scalar(@{$dot_files_ref}); $i++) {
        my $snapshot_file = $dot_files_ref->[$i];

        open(my $snapshot_fh, "<$snapshot_file") 
            or die("Could not open $snapshot_file");

        # Iterate through requests
        my $old_byte_offset = 0;
        while(<$snapshot_fh>) {
            my %req_edge_latency_hash;
            my %node_name_hash;
            my $request_latency;
            my $local_id;
            
            if(/\# (\d+)  R: ([0-9\.]+)/) {
                $local_id = $1;
                $request_latency = $2;
            } else {
                $old_byte_offset = tell($snapshot_fh);
                next;
            }
	  	    
            #generate the snapshot index and global id to local id mapping
            printf $snapshot_idx_fh "$i $local_id $old_byte_offset\n";
            printf $gid_to_lid_idx_fh "$self->{GLOBAL_ID} $local_id $snapshot $i\n";
          
	    #generate the global id to request latency mapping
	    printf $gid_to_latency_fh "$self->{GLOBAL_ID} $request_latency\n";

            # Skip the Begin Digraph { line
            $_ = <$snapshot_fh>;
            
            DotHelper::parse_nodes_from_file($snapshot_fh, 1, \%node_name_hash);
            $self->$_handle_edges($snapshot_fh, \%node_name_hash, \%req_edge_latency_hash,
                                  $request_latency, $snapshot);
            
            $self->{GLOBAL_ID}++;
        }

        close($snapshot_fh);
    }

    close($gid_to_lid_idx_fh);
    close($gid_to_latency_fh);
    close($snapshot_idx_fh);
};



### API Functions #########################


##
# Constructor for this class
#
# @param proto: 
# @param snapshot0_files_ref: Reference to an array of filenames
# @param snapshot1_files_ref: Reference to an array of filenames (Optional)
# @param output_dir: The directory in which the output files should be placed
##
sub new {
    my ($proto, $snapshot0_files_ref, 
        $snapshot1_files_ref, $output_dir);
    
    if (scalar(@_) == 4) {
        ($proto, $snapshot0_files_ref, 
         $snapshot1_files_ref, $output_dir) = @_;
    } elsif (scalar(@_) == 3) {
        ($proto, $snapshot0_files_ref, 
         $output_dir) = @_;
    } else {
        print "Invalid number of input arguments\n";
        assert(0);
    }
        
    my $class = ref($proto) || $proto;

    my $self = {};

    $self->{SNAPSHOT0_FILES_REF} = $snapshot0_files_ref;
    if(defined $snapshot1_files_ref) {
        $self->{SNAPSHOT1_FILES_REF} = $snapshot1_files_ref;
    } else {
        $self->{SNAPSHOT1_FILES_REF} = undef;
    }

    # Output file names and hashes for this class
    $self->{S0_REQUEST_INDEX_FILE} = "$output_dir/s0_request_index.dat";

    # Global ID to request latency
    $self->{GLOBAL_IDS_TO_LATENCIES_FILE} = "$output_dir/global_ids_to_latencies.dat";
    
    # Global ID to local ID
    $self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE} = "$output_dir/global_ids_to_local_ids.dat";
    $self->{STARTING_GLOBAL_ID} = 1;
    $self->{GLOBAL_ID} = $self->{STARTING_GLOBAL_ID};

    # Output files generated only if a snapshot1 file is provided
    if(defined $self->{SNAPSHOT1_FILES_REF}) {
        $self->{S1_REQUEST_INDEX_FILE} = "$output_dir/s1_request_index.dat";
    } else {
        $self->{S1_REQUEST_INDEX_FILE} = undef;
    }
    
    bless($self, $class);
    return $self;
}


##
# Checks if the output files created by this class already
# exist.
#
# @param self: The object-container
##
sub do_output_files_exist {

    assert(scalar(@_) == 1);
    my ($self) = @_;
    
    if(-e $self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE}) {
        if(-e $self->{S0_REQUEST_INDEX_FILE}) {
            if(defined $self->{SNAPSHOT1_FILES_REF}) {       
                # Must also check to see if output files specific to
                # snapshot 1 already exist
                if(-e $self->{S1_REQUEST_INDEX_FILE}) {
                    # All output files for snapshot1 and snapshot1 exist
                    return 1;
                }
                # Output files for snapshot1 do not exist
                return 0;
            }
            # No snapshot1 file; output files for snapshot0 exist
            return 1;
        }
    }

    # $self->{GLOBAL_IDS_TO_LOCAL_IDS_FILE} does not exist
    return 0;
}


##
# Iterates through requests in the snapshot files seperates and creates
# indices on them so that they can be accessed easily in the future
#
# @param self: The object container
##
sub parse_requests {

    assert(scalar(@_) == 1);
    my ($self) = @_;

    $self->$_remove_existing_files();

    $self->$_handle_requests($self->{SNAPSHOT0_FILES_REF},
                            $self->{S0_REQUEST_INDEX_FILE},
                            0);
    if(defined $self->{SNAPSHOT1_FILES_REF}) {
        $self->$_handle_requests($self->{SNAPSHOT1_FILES_REF},
                               $self->{S1_REQUEST_INDEX_FILE},
                               1);
    }
}


1;


 



   

    

    
