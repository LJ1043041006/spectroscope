#! /usr/bin/perl -w

#
# Copyright (c) 2013, Carnegie Mellon University.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
# HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
# WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

# $cmuPDL: PassThrough.pm,v 1.4 2009/08/06 17:33:20 rajas Exp $
##
# This perl modules implements a "ClusteringPassThrough"
# that is, it generates as many clusters as input
# datapoints.  This code generates the following output file:
#
# clusters.dat: A file, where each row represents a cluster.  
# The first column represents the offset into the input 
# vector file of the cluster representative the other other 
# columns indicate offsets of the datapoints assigned to the cluster.
#
# clusters_distance_matrix.dat: This file contains a matrix 
# specifying the distance between different clusters.  It is 
# 1-indexed.  This file is in MATLAB sparse matrix format.
#
# The code takes as input a data vector, where each row is a datapoint
# and each column a dimension.  The first two columns of each row
# are: <number of reqs in s0, number of reqs in s1>
##

package PassThrough;

use strict;
use Getopt::Long;
use Test::Harness::Assert;


#### Private functions #######################

##
# Removes existing files created by this perl module,
# if they already exist in the output directory
#
# @param self: The object container
##
my $_remove_existing_files = sub {
    my $self = shift;

    if(-e $self->{INPUT_VECTOR_FILE}) {
        print("Deleting old $self->{INPUT_VECTOR_FILE}\n");
        system("rm -f $self->{INPUT_VECTOR_FILE}") == 0
            or die("Could not delete old $self->{INPUT_VECTOR_FILE}\n");
    }
};


#### API functions ###############################

sub new {
    assert(scalar(@_) == 4);
    my ($proto, $input_dir, $output_dir, $sed) = @_;

    my $class = ref($proto) || $proto;

    my $self = {};

    # Input files
    $self->{INPUT_VECTOR_FILE} = "$input_dir/input_vector.dat";
    $self->{INPUT_DISTANCE_MATRIX_FILE} = $sed->get_distance_matrix_file();

    # Output files
    $self->{CLUSTER_DISTANCE_MATRIX_FILE} = "$input_dir/clusters_distance_matrix.dat";
    $self->{CLUSTER_FILE} = "$output_dir/clusters.dat";

    bless($self, $class);
    return $self;
}


##
# Returns 1 if the output file generated by this class
# already exists in the output directory
#
# @param self: The object-container
##
sub do_output_files_exist {
    my $self = shift;

    if ( -e($self->{CLUSTER_FILE}) &&
         -e($self->{CLUSTER_DISTANCE_MATRIX_FILE})) {
        return 1;
    }

    return 0;
}


##
# Iterates through the input vector and 
# spits out the line number to the clusters.dat file.
#
# @param self: The object container
##
sub cluster {
    my $self = shift;
    
    open(my $input_vector_fh, "<$self->{INPUT_VECTOR_FILE}") 
        or die("Could not open $self->{INPUT_VECTOR_FILE}");
    open(my $output_fh, ">$self->{CLUSTER_FILE}")
        or die("Could not open $self->{CLUSTER_FILE}");
    
    my $offset = 1;
    while (<$input_vector_fh>) {
        print $output_fh "$offset\n";
        $offset++;
    }

    if( -e $self->{INPUT_DISTANCE_MATRIX_FILE}) { 
        system("cp $self->{INPUT_DISTANCE_MATRIX_FILE} " .
               "$self->{CLUSTER_DISTANCE_MATRIX_FILE}") == 0
               or die "Could not create $self->{CLUSTER_DISTANCE_MATRIX_FILE}";
    }

    close($input_vector_fh);
    close($output_fh);
}


1;
