#! /user/bin/perl -w

# $cmuPDL: DecisionTree.pm,v 1.64 2009/03/13 19:39:19 source Exp $
##
# @author Raja Sambasivan
#
# @brief Provides an API for using a decision tree
# to find the low-level data that best separates
# two clusters of request-flow graphs
##

package DecisionTree;

use strict;
use warnings;
use diagnostics;
use Test::Harness::Assert;
use DBI;
use Data::Dumper;

use ExplainClusters::MatchGraphs qw[match_graphs];

#### Private functions ######


#### Public functions #######

##
# The object constructor
#
# @param proto: Passed in automatically
# @param request_info_obj: A instantiation of the PrintGraphs class
# that defines how to print and obtain information about requests in
# the input datasets
# @param parse_clustering_results_obj: A instantiation of the 
# ParseClusteringResults class that can be used to obtain info about
# the request clusters
# @param output_dir: The directory in which output should be placed
# @param s0_database_file: Database containing low-level information
# about requests in snapshot0
# @param s1_database_file: Database containing low-level information
# about requests in snapshot1
#
# @return An object of class DecisionTree
##
sub new {

    assert(scalar(@_) == 5 ||
           scalar(@_) == 6);

    my $proto = shift;
    my $request_info_obj = shift;
    my $parse_clustering_results_obj = shift;
    my $output_dir = shift;
    my $s0_database_file = shift;
    my $s1_database_file;
    if(scalar(@_) == 1) {
        $s1_database_file = shift;
    }

    # Make sure all input was specified
    assert(defined $proto && defined $request_info_obj
           && defined $parse_clustering_results_obj 
           && defined $s0_database_file
           && defined $output_dir);

    my $class = ref($proto) || $proto;

    # Fill in $self structure
    my $self = {};
    $self->{S0_DB_CONN} = DBI->connect( "dbi:SQLite:$s0_database_file" ) ||
        die("Could not connect to $s0_database_file: DBI:errstr\n");
    if (defined $s1_database_file) {
        $self->{S1_DB_CONN} = DBI->connect( "dbi:SQLite:$s1_database_file" ) ||
            die("Could not connect to $s1_database_file: DBI:errstr\n");
    }
    else {
        $self->{S1_DB_CONN} = undef;
    }

    $self->{REQUEST_INFO_OBJ} = $request_info_obj;
    $self->{PARSE_CLUSTERING_RESULTS_OBJ} = $parse_clustering_results_obj;

    bless($self, $class);
}
 

##
# Given the ID of a mutated cluster and the original cluster,
# this function generates a regression tree that attempts to 
# separate the two clusters using the low-level data referred
# to by the constituent requests.  When this function returns,
# output_dir will be populated by the decision rules and tree
# generated by the C4.5 classifier.
#
# @param original_cluster_id: ID of requests in the original cluster
# @param mutated_cluster_id: ID of requests in the mutated cluster
# @param output_dir: Location in which the output regression tree
#  rules should be placed
# 
sub explain_clusters {
    assert(scalar(@_) == 4);

    my $self = shift;
    my $mutated_cluster_id = shift;
    my $original_cluster_id = shift;
    my $output_dir = shift;

    my $request_info_obj = $self->{REQUEST_INFO_OBJ};
    my $clustering_results_obj = $self->{PARSE_CLUSTERING_RESULTS_OBJ};

    my $original_request_id = 
        $clustering_results_obj->get_global_id_of_cluster_rep($original_cluster_id);
    my $mutated_request_id = 
        $clustering_results_obj->get_global_id_of_cluster_rep($mutated_cluster_id);

    my $original_req_container =        
        $request_info_obj->get_req_structure_given_global_id($original_request_id);
    my $mutated_req_container = 
        $request_info_obj->get_req_structure_given_global_id($mutated_request_id);

    my $matching_nodes_list = MatchGraphs::match_graphs($original_req_container->{ROOT},
                                                        $original_req_container->{NODE_HASH},
                                                        $mutated_req_container->{ROOT},
                                                        $mutated_req_container->{NODE_HASH});

    print Dumper(@$matching_nodes_list);
    

}


1;
    
    
